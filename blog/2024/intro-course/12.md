---
title: "【第12回】グラフの復習とUnion-Find"
description: "BFS、DFSをしっかり復習しよう"
date: "2024-10-22"
authors: ["shigekk"]
tags: ["入門講習会", "atcoder", "競技プログラミング", "cpp"]
prev: "./11"
---

## グラフの復習

* 前回行ったBFS、DFSについて復習しましょう。
BFSとDFSの違いを理解しておくと、問題を解く際に役立ちます。

### BFS(幅優先探索)

* 最短経路の発見が得意。
* 先に見つけた頂点から探索。
* queueを使って実装する。

### DFS(深さ優先探索)

* 木の探索が得意。
* 後から見つけた頂点から探索。
* stackを使って実装する。

## グラフ探索のテンプレート

### BFS(幅優先探索)

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<int>> g(n);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u); // 無向グラフの場合
    }

    vector<int> dist(n, -1);
    queue<int> q;

    int start = 0; // 開始点を0とする
    dist[start] = 0;
    q.push(start);

    while (!q.empty()) {
        int v = q.front();
        q.pop();

        for (int i = 0; i < g[v].size(); i++) {
            int next = g[v][i];
            if (dist[next] == -1) {
                dist[next] = dist[v] + 1;
                q.push(next);
            }
        }
    }

    // 距離配列の出力をする場合
    for (int i = 0; i < n; i++) {
        cout << i << dist[i] << endl;
    }

    return 0;
}

```

:::details[グリッドを探索する場合]

```cpp
#include <bits/stdc++.h>
using namespace std;

// 移動方向（上下左右）
const int dx[4] = {1, -1, 0, 0};
const int dy[4] = {0, 0, 1, -1};

int main() {
    int h, w;
    cin >> h >> w;

    vector<string> grid(h);
    for (int i = 0; i < h; i++) {
        cin >> grid[i];
    }

    vector<vector<int>> dist(h, vector<int>(w, -1));
    queue<pair<int, int>> q;

    // 0,0を開始点として設定
    dist[0][0] = 0; 
    q.push({0, 0});

    while (!q.empty()) {
        auto [x, y] = q.front();
        q.pop();

        // 上下左右の隣接セルを探索
        for (int dir = 0; dir < 4; dir++) {
            int nx = x + dx[dir];
            int ny = y + dy[dir];

            // グリッドの範囲内かつ未訪問で'.'のセルならば進む
            if (nx >= 0 && nx < h && ny >= 0 && ny < w && grid[nx][ny] == '.' && dist[nx][ny] == -1) {
                dist[nx][ny] = dist[x][y] + 1;
                q.push({nx, ny});
            }
        }
    }

    // 距離配列の出力をする場合
    for (int i = 0; i < h; i++) {
        for (int j = 0; j < w; j++) {
            if (dist[i][j] == -1) {
                cout << "# ";
            } else {
                cout << dist[i][j] << " ";
            }
        }
        cout << endl;
    }

    return 0;
}

```

:::

### DFS(深さ優先探索)

```cpp
#include <bits/stdc++.h>
using namespace std;

void dfs(int start, const vector<vector<int>>& adj, vector<bool>& visited) {
    stack<int> st;
    st.push(start); // 開始点をスタックに追加

    while (!st.empty()) {
        int v = st.top();
        st.pop();

        if (visited[v]) continue;

        visited[v] = true;

        //ノードをスタックに追加
        for (int i = adj[v].size() - 1; i >= 0; i--) {
            int next = adj[v][i];
            if (!visited[next]) {
                st.push(next);
            }
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<int>> adj(n);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u); // 無向グラフの場合
    }

    vector<bool> visited(n, false);

    int start = 0; // 開始点を0とする
    dfs(start, adj, visited);

    return 0;
}

```

:::details[グリッドを探索する場合]

```cpp
#include <bits/stdc++.h>
using namespace std;

// 移動方向（上下左右）
const int dx[4] = {1, -1, 0, 0};
const int dy[4] = {0, 0, 1, -1};

void dfs(int start_x, int start_y, const vector<string>& grid, vector<vector<bool>>& visited) {
    int h = grid.size();
    int w = grid[0].size();

    stack<pair<int, int>> st;
    st.push({start_x, start_y}); // 開始点をスタックに追加

    while (!st.empty()) {
        auto [x, y] = st.top();
        st.pop();

        if (visited[x][y]) continue; // 既に訪問済みならスキップ
        visited[x][y] = true; // 訪問済みにする

        // 上下左右の隣接セルを探索
        for (int dir = 0; dir < 4; dir++) {
            int nx = x + dx[dir];
            int ny = y + dy[dir];

            // グリッドの範囲内かつ未訪問で'.'のセルならば進む
            if (nx >= 0 && nx < h && ny >= 0 && ny < w && grid[nx][ny] == '.' && !visited[nx][ny]) {
                st.push({nx, ny});
            }
        }
    }
}

int main() {
    int h, w;
    cin >> h >> w;

    vector<string> grid(h);
    for (int i = 0; i < h; i++) {
        cin >> grid[i];
    }

    vector<vector<bool>> visited(h, vector<bool>(w, false)); // 訪問フラグ

    int start_x = 0, start_y = 0; // 開始点を(0,0)に設定
    if (grid[start_x][start_y] == '.') {
        dfs(start_x, start_y, grid, visited);
    }

    // 訪問結果の出力する場合
    for (int i = 0; i < h; i++) {
        for (int j = 0; j < w; j++) {
            if (visited[i][j]) {
                cout << "O "; // 訪問済みのセルを'O'で表示
            } else {
                cout << grid[i][j] << " ";
            }
        }
        cout << endl;
    }

    return 0;
}

```

:::

### 演習問題

<https://atcoder.jp/contests/abc264/tasks/abc264_d>

<https://atcoder.jp/contests/abc277/editorial/5209>

<https://atcoder.jp/contests/abc150/tasks/abc150_c>

## Union-Find
