---
title: "【第14回】動的計画法(DP)"
description: "動的計画法を紹介します"
date: "2024-11-05"
authors: ["llstream"]
tags: ["入門講習会", "atcoder", "競技プログラミング", "cpp"]
prev: "./13"
---

## 動的計画法(DP法)

動的計画法(DP法)とは一度求めた解を利用してほかの解を求めていく解き方です.
わかりやすいものとして漸化式が挙げられます.
例として以下の問題を利用して解説します

<https://atcoder.jp/contests/dp/tasks/dp_a>

この問題を解くコードは以下です

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<int> h(n),dp(n);
    for ( int i = 0; i < n; i++ ) {
        cin >> h.at(i);
    }
    dp.at(0) = 0;
    dp.at(1) = abs(h.at(1)-h.at(0));
    for ( int i = 2; i < n; i++ ) {
        dp.at(i) = min(dp.at(i-1)+abs(h.at(i)-h.at(i-1)),dp.at(i-2)+abs(h.at(i)-h.at(i-2)));
    }
    cout << dp.at(n-1) << endl;
}
```

今回の問題では、それぞれの足場に移動するコストを配列$dp$で管理しています。$i$番目の足場に移動する際、$i-1$番目の足場か$i-2$番目の足場から移動する必要があるので、移動のコストとその足場までのコストの合計$|h.at(i)-h.at(i-1)|+dp.at(i-1)$と$|h.at(i)-h.at(i-2)|+dp.at(i-2)$を比較して少ない方を|dp.at(i)|に代入するという方法で$i$番目の足場まで移動するためのコストを求めることができます。
![DP法](/images/blog/intro-course-14/dp-setumei.png)
そして、$dp.at(0)=0$,　$dp.at(1)=|h.at(1)-h.at(0)|$とすることで解くことができます。
