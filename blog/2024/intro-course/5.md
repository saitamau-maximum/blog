---
title: "【第5回】はじめての競技プログラミング"
description: "set,mapを紹介します"
date: "2024-06-25"
authors: ["hana-rs"]
tags: ["入門講習会", "atcoder", "競技プログラミング", "cpp"]
prev: "./4"
---

## set

- `set`型は集合を表す。
- `set`型を使うことで、要素の重複を許さず、要素の追加、削除、検索が高速に行える。

### 使い方

例として`set`型の変数をsとする。

| 関数 | 機能 | 計算量 |
| :--- | :--- | :--- |
| `set<型> s;` | set型の変数sを宣言する | O(1) |
| `s.insert(x);` | set型の変数sにxを挿入する | O(logN) |
| `s.erase(x);` | set型の変数sからxを削除する | O(logN) |
| `s.find(x)` | set型の変数sからxを探す | O(logN) |
| `s.count(x)` | set型の変数sにxが含まれているかどうかを調べる | O(logN) |
| `s.size()` | set型の変数sの要素数を取得する | O(1) |
| `s.empty()` | set型の変数sが空かどうかを調べる | O(1) |
| `s.clear()` | set型の変数sを空にする | O(N) |
| `*s.begin()` | set型の変数sの最小値を取得する | O(1) |
| `*s.rbegin()` | set型の変数sの最大値を取得する | O(1) |
| `set<型> s(A.begin(), A.end());` | 配列Aをset型の変数sに変換する | O(NlogN) |

### 使い方の例

- `int`型の例

```cpp
set<int> s;
for (int i = 1; i <= 5; i++) {
    s.insert(i);
}
for (int i = 1; i <= 5; i++) {
    if (s.count(i)) {
        cout << i << "は含まれています" << endl;
    } else {
        cout << i << "は含まれていません" << endl;
    }
}
```

- `set`型の変数sには、1, 2, 3, 4, 5が含まれている。
- 1から5までの整数が含まれているかどうかを調べる。
- 1から5までの整数はすべて含まれているので、1から5までの整数が含まれていますと出力される。

- `string`型の例

```cpp
set<string> s;
s.insert("apple");
s.insert("banana");
s.insert("orange");
if (s.count("apple")) {
    cout << "appleは含まれています" << endl;
} else {
    cout << "appleは含まれていません" << endl;
}
```

- `set`型の変数sには、"apple", "banana", "orange"が含まれている。
- "apple"が含まれているかどうかを調べる。
- "apple"は含まれているので、"appleは含まれています"と出力される。

### multiset

- `multiset`型は`set`型と同じく集合を表すが、要素の重複を許す。
- 使い方は`set`型と同じ。
- eraseは、その要素すべてが削除される。
- 要素を1つだけ削除したい場合は、s.erase(s.find(x))を使う。

```cpp
multiset<int> s;
s.insert(1);
s.insert(2);
s.insert(2);
s.insert(3);
s.insert(3);
s.erase(2); // 2を削除
s.erase(s.find(3)); // 3を1つだけ削除
```

- この場合、sには1, 3が含まれている。

### 問題

<https://atcoder.jp/contests/abc268/tasks/abc268_a>

:::details[ヒント]

- for文で回しながら、対象となる数値がsetに含まれているかどうかを確認しよう

:::

:::details[解答例]

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  set<int> st;
  int ans=0;
    for (int i = 1; i <= 5; i++) {
        int a;
        cin >> a;
        if(!st.count(a)){
          ans++;
          st.insert(a);
        }
    }
    cout << ans << endl;
}
```

- for文で回しながら、対象となる数値がsetに含まれているかどうかを確認し、含まれていない場合はsetに追加する。
- setに追加する際に、追加した数値の個数をカウントする。
- setに既に追加されている数字が入力された場合は、if文以降が無視されるため、カウントされない。

:::

## map

- `map`型は連想配列を表す。

### 使い方

例として`tuple`型の変数をPとする。

| 関数 | 機能 |
| :--- | :--- |
| `tuple<型1, 型2, ...> P;` | tuple型の変数Pを宣言する |
| `tuple<型1, 型2, ...> P(a, b, ...);` | tuple型の変数Pを宣言し、(a, b, ...)で初期化する |
| `get<i>(P)` | tuple型の変数Pのi番目の要素にアクセスする |
| `make_tuple(a, b, ...)` | a, b, ...を要素とするtuple型の変数を作成する |
| `tie(a, b, ...) = P` | tuple型の変数Pの要素をa, b, ...に代入する |

- ただし、for文を使って`tuple`型の変数の要素にアクセスすることはできない。
- `i`は定数である必要があり、実装時は`0, 1, 2, ...`などの値で書く必要がある。

```cpp
int i = 3;
get<i>(P); // これはエラー
get<3>(P); // これはOK
```

### 使い方の例

- 人の苗字、名前、年齢

```cpp
tuple<string, string, int> person;
person = make_tuple("Yamada", "Taro", 20);
cout << get<0>(person) << " " << get<1>(person) << " " << get<2>(person) << endl;  // Yamada Taro 20
```

- `tuple`を"普通の"型・`pair`型の代わりに使うこともできる

```cpp
tuple<int> a(0);
tuple<int, int> b(1, 2);
cout << get<0>(a) << endl; // 0
cout << get<0>(b) << " " << get<1>(b) << endl;  // 1 2
```

### 問題

<https://atcoder.jp/contests/abc128/tasks/abc128_b>

:::details[解答例]

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < (n); ++i)
int main() {
    int n;
    cin >> n;
    vector<tuple<string, int, int>> abc(n);
    rep(i, n) {
        string a;
        int b;
        cin >> a >> b;
        abc[i] = { a, b, i+1 };
    }
    // 1番目の値でソート、同じなら2番目の値が大きい順でソート
    sort(abc.begin(), abc.end(), [](tuple<string, int, int> a, tuple<string, int, int> b) {
        if (get<0>(a) == get<0>(b)) {
            return get<1>(a) > get<1>(b);
        }
        else {
            return get<0>(a) < get<0>(b);
        }
    });
    // 3番目の値を出力
    rep(i, n) {
        cout << get<2>(abc[i]) << endl;
    }
}
```

:::

### pair/tupleを使う意味

`vector`だと`a[0]`とかで書けて楽なのに何故`pair`/`tuple`を使うのか？

#### 1. 要素数が変わらないから

- `vector`だと`push_back()`などで要素数を増やすことができる。
- しかし、要素数を変更するとfor文が使いにくくなる。
- 格納データが数個程度であれば、`pair`/`tuple`を使った方が楽。

#### 2. 複数の型を1つの変数に格納できるから

- `vector`は同じ型のデータしか格納できない。
- それに対して`pair`/`tuple`は異なる型のデータを1つの変数に格納できる。

### pair/tupleの分解

- いちいち`x = a.first`, `y = a.second`, `z = get<0>(b)`みたいに書くことは面倒。
- **構造化束縛**を使うと楽に書くことができる。

- pairの構造化束縛

```cpp
pair<string, double> a("fooo", 123.4);

auto [x, y] = a;
// これは以下の文と同じ
string x = a.first;
double y = a.second;
```

- tupleの構造化束縛

```cpp
tuple<string, double, int> a("fooo", 123.4, 42);

auto [x, y, z] = a;
// これは以下の文と同じ
string x = get<0>(a);
double y = get<1>(a);
int z = get<2>(a);
```

### auto型

#### 構造化束縛で`auto[x, y] = a`と書いた、`auto`とは？

- コンパイラが自動で型を推論してくれるので、型を省略できる場合に使える。
- 逆に、推論できないような場所では使えない。
- 可読性が下がってしまう可能性も…

```cpp
string concat(string a, string b) {
    return a + b;
}

int main(){
  string a = "Hello";
  string b = "World";
  auto ab = concat(a, b);
  cout << ab << endl;

  vector<int> c = {1, 2, 3};
  auto d = c;

  pair<int, string> e(10, "foo");
  auto [x, y] = e;
}

```

- abの型は？
`concat`関数は`string`型を返す→abは`string`型!
- dの型は？
dにcを代入する処理→cと同じ`vector<int>`型!
- x, yの型は？
`pair<int, string>`の1つ目がxに、2つ目がyに代入される→xは`int`型、yは`string`型!

## 型エイリアス

### 型エイリアスとは？

- `tuple<int, int, int>`や、場合によっては`tuple<vector<vector<vector<…>>>>`などのコードを書くことがあるが、いちいち書くのは大変。
- 一方で、`auto`型を使えない/使いたくない場合もある。
- そこで、**型エイリアス**を使うと、型に別名をつけることができる。

### 使い方

- `using <別名> = <元の型>;` を `using namespace std;` の後に書く。
- いくつ別名を定義してもいいし、同じ型に対していくつ別名を付けても良い。
- ただし、既に定義されている型を別の型のエイリアスとして用いることはできない。

```cpp
#include <bits/stdc++.h>
using namespace std;

//いくつ書いてもOK
using ll = long long;
using lll = long long;
using ull = unsigned long long;

int main() {
  ll x = 1'000'000'000'000'000'000;
  //これは以下と同じ
  long long x = 1'000'000'000'000'000'000;
  //同じ long long 型に対して別名をつけているので、これも同じになる
  lll x = 1'000'000'000'000'000'000;
}
```

- 例えば、`vector<vector<vector<vector<int>>>>` 型を`int4D`という名前で使いたい場合、以下のように書く。

```cpp
using int4D = vector<vector<vector<vector<int>>>>;
```

- よく使うもの一覧(スニペットに登録しておくと便利！)

```cpp
using ll = long long;
using P = pair<int, int>;
using T = tuple<int, int, int>;
```

## 練習問題

### `set`型

#### Lv.1

- <https://atcoder.jp/contests/abc089/tasks/abc089_b>
- <https://atcoder.jp/contests/abc240/tasks/abc240_b>
- <https://atcoder.jp/contests/abc164/tasks/abc164_c>

#### Lv.2

- <https://atcoder.jp/contests/abc073/tasks/abc073_c>
- <https://atcoder.jp/contests/abc116/tasks/abc116_b>
- <https://atcoder.jp/contests/abc291/tasks/abc291_c>

#### Lv.3

- <https://atcoder.jp/contests/abc310/tasks/abc310_c>
- <https://atcoder.jp/contests/abc251/tasks/abc251_c>
- <https://atcoder.jp/contests/abc294/tasks/abc294_d>
