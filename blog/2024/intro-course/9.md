---
title: "【第9回】順列全探索と二分探索"
description: "場面に応じた探索をしよう！"
date: "2024-07-23"
authors: ["shigekk"]
tags: ["入門講習会", "atcoder", "競技プログラミング", "cpp"]
prev: "./8"
---

## 競プロにおける探索

競技プログラミングにおいて探索といえば、条件を満たすような値や要素を見つけることを示すでしょう。すべての要素から探す、すべての状況を試すといった選択を採れることは手計算には無い強みです。第7回で学んだ計算量の概念を意識しながら、状況に応じた効率的な探索方法を選ぶことが重要になってきます。

## 順列全探索

順列全探索とは、ある数列の全ての順列を列挙する方法です。順列全探索は、全ての順列を列挙するため、計算量は $O(N!)$ となります。$N$ が大きい場合は計算量が膨大になるため注意が必要で、$N \leq 10$ 程度が限界とされています。

### 順列全探索の実装

C++ では `next_permutation` という関数を使うことで簡単に順列全探索を実装することができます。`next_permutation` は、引数に与えられた数列を次の順列に変更し、次の順列が存在する場合は `true` を返し、存在しない場合は `false` を返します。  
順列全探索を行う際は、数列を昇順にソートしておくことが必要です。

以下に、数列 `{1, 2, 3}` の全ての順列を列挙するコードを示します。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    vector<int> v = {1, 2, 3};
    do {
        for (int i = 0; i < v.size(); i++) {
            cout << v.at(i) << " ";
        }
        cout << endl;
    } while (next_permutation(v.begin(), v.end()));
}
```

出力結果:

```text
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

## 二分探索

二分探索は、ソートされた数列に対して、探索対象の値を半分に分割して探索する方法です。二分探索は、計算量が $O(\log N)$ となるため、$N$ が大きい場合でも高速に探索することができます。  
ある値が含まれているかどうかを調べるだけでなく、条件を満たす最小の値や最大の値を求めることもできます。  
与えられた配列に特定の値が含まれるかを判定するプログラムの例を示します。

配列 `{38, 44, 71, 57, 85, 47, 12, 91, 88, 25}` に対して、値 `44` が含まれているかを判定

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {38, 44, 71, 57, 85, 47, 12, 91, 88, 25};
    sort(v.begin(), v.end()); //まずソートする
    int target = 44; //44が含まれているかを調べる
    int L = 0, R = v.size(); //Lは左端、Rは右端
    while (R - L > 1) {
        int M = (L + R) / 2; //中央のインデックス
        if (v.at(mid) <= target) { //中央の値がtarget以下なら
            L = M; //左端を中央に
        } else { //中央の値がtargetより大きいなら
            R = M; //右端を中央に
        }
    }
    if (v.at(L) == target) cout << "Found" << endl;
    else cout << "Not Found" << endl;
}
```

出力結果:

```text
Found
```

二分探索のイメージ
![二分探索](/images/blog/intro-course-9/image.png)
