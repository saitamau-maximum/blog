---
date: "2023-05-23"
title: "【第5回】計算量とbit演算"
author: "kasa021"
tags: ["入門講習会", "algorithm", "atcoder", "競技プログラミング", "cpp"]
layout: default
---

# 計算量について

## アルゴリズム

ある処理を行うプログラムを作るとき、どのように処理を行うのかという計算手順のことをアルゴリズムと呼びます。

- 例: 1 から n までの和を求めるプログラム
  - 1 から n までの数を順番に足していく : n-1 回の計算を行う
  - 等差数列の公式を用いて$\frac{n(n+1)}{2}$ を計算する : 3 回の計算を行う

このように、同じ処理を行うプログラムでも、複数のアルゴリズムを考えることができます。コンピュータも 1 回の計算には時間がかかるので、処理を早く終わらせるためには、より効率の良いアルゴリズムを考える必要があります。アルゴリズムの大まかな性能を表す指標として、計算量というものがあります。

## 計算量

プログラムは入力に対して必要な計算を行い結果を出力する。この時の計算時間や記憶領域の量がどのくらい変化するのかが計算量です。計算量には、時間計算量と空間計算量があります。

- 時間計算量: 計算の回数
- 空間計算量: 必要な記憶領域の量

たんに計算量という時は、時間計算量をさすことが多いです。

先ほどの 1 から n までの和を求めるプログラムの例で考えてみよう。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int N;
    cin>>N;
    int sum=0;
    for(int i=1;i<=N;i++){
        sum+=i;
    }
    cout<<sum<<endl;
}
```

このプログラムでは、for 文を n 回繰り返しているので、計算回数はおおよそ n 回になります。このとき時間計算量はオーダー記法を用いて$O(n)$と表します。このように、計算量を表すときには、計算回数ではなく、計算回数のオーダーを表します。

## オーダー記法

厳密に時間計算量、空間計算量を求めることは大変です。そこでざっくりと計算量を表すために、オーダー記法$O()$を用います。

- 例: $3N^3+10N^2+2$ という式があったとき、$O(N^3)$と表す。
  　- 定数倍は無視する
  　- N が大きくなった時、最も影響が大きい項のみを考える

$N=1000$の時、$N^3=1000000000=10^9$,$N^2=1000000=10^6$であり、$N^3$は$N^2$の量を無視できるほど大きいので、$O(N^3)$と表します。
$N$を無限大に近づけた時の発散スピードを考えるとイメージしやすいかもしれません。

![Plot](/images/plot.png =600x)

この図を見ると計算量の大まかなイメージがつかめると思います。

$O(1) < O(\logN) < O(N) < O(NlogN) < O(N^2) < O(2^N) < O(N!)$

## 例題

以下の式のオーダー記法を答えよ。

1. $N+100$
2. $3N^2+2N+1$
3. $10+2$
4. $2^N+N^3+N$
5. $N!+N^2+1$
6. $Nlog(N)+N$
7. $N^2+N^2log(N)$

:::details 答え

1. $O(N)$
2. $O(N^2)$
3. $O(1)$
4. $O(N^3)$
5. $O(N!)$
6. $O(Nlog(N))$
7. $O(N^2log(N))$
   :::

## コードを見てみよう

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int N;
    cin>>N;
    int sum=0;
    for(int i=1;i<=N;i++){
        sum+=i;
    }
    cout<<sum<<endl;
}
```

さっき出てきたコードを同じです。これは for 文で処理を$N$回繰り返しているので、$O(N)$であらわされます。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int N;
    cin>>N;
    int sum=0;
    for(int i=1;i<=N;i++){
        for(int j=1;j<=N;j++){
            sum+=i*j;
        }
    }
    cout<<sum<<endl;
}
```

このコードは for 文が 2 重になっているので、$O(N^2)$であらわされます。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int N;
    cin>>N;
    int count=0;
    while(N>0){
        N/=2;
        count++;
    }
    cout<<count<<endl;
}
```

このコードは$N$を$2$で割り続けているので、$N$を割る回数を$x$とすると$N (\frac{1}{2})^x = 1$で
表せます。この式の両辺を$\log$をとると、$x=log_2(N)$となります。
よって、$O(logN)$であらわされます。
計算量の$\log$は底はなんでもいいです。底の変換公式より、$log_a(N)=\frac{log_b(N)}{log_b(a)}$なので、定数とみなせます。
今回は、$\log_2(N)$になります。


```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int N;
    cin>>N;
    int count=0;
    vector<int> a(N);
    rep(i,N){
        cin>>a[i];
    }
    do{
        count++;
    }while(next_permutation(a.begin(),a.end()));
    cout<<count<<endl; //N!
}
```

このコードは、$N$個の数列の順列を全て列挙しています。順列の数は$N!$なので、$O(N!)$であらわされます。

## 競プロでの計算量

AtCoder の問題では、`実行時間制限`、`メモリ制限`があるので計算量をよく考えます。
基本的には、1秒あたり$10^8$~$10^9$あたりまでは許されます。

- $O(10^8)$ : まあ行ける
- $O(10^9)$ : 単純な処理、加算、減算くらいならいける
- $O(10^{10})$ : まあムリ

### 目安

|    制約     | 間に合うオーダー | 使うアルゴリズム例 |
| :---------: | :--------------: | :----------------: |
|   $N<=10$   |     $O(N!)$      |     順列全探索     |
|   $N<=25$   |     $O(2^N)$     |     bit 全探索     |
|  $N<=200$   |     $O(N^3)$     | ワーシャルフロイド |
|  $N<10^4$   |     $O(N^2)$     |     二重ループ     |
|  $N<=10^5$  |    $O(NlogN)$    |       ソート       |
|  $N<=10^8$  |      $O(N)$      |      線形探索      |
| $N<10^{14}$ |      $O(\sqrt{N})$      |      素数判定      |
|  それ以上   |    $O(logN)$     |      二分探索      |
||$O(1)$|定数時間|
## 例題

<https://atcoder.jp/contests/apg4b/tasks/APG4b_cb>

::::details 解説

- f0

```cpp
 int f0(int N) {
  return 1;
}
```

これは$O(1)$です。$N$に関係なく、常に 1 回の計算で終わります。

- f1

```cpp
int f1(int N, int M) {
  int s = 0;
  for (int i = 0; i < N; i++) {
    s++;
  }
  for (int i = 0; i < M; i++) {
    s++;
  }
  return s;
}
```

これは$O(N+M)$です。$N$と$M$の値によって計算回数が変わります。

- f2

```cpp
int f2(int N) {
  int s = 0;
  for (int i = 0; i < N; i++) {
      int t = N;
      int cnt = 0;
      while (t > 0) {
        cnt++;
        t /= 2;
      }
      s += cnt;
  }
  return s;
}
```

これは$O(NlogN)$です。$log(N)$を$N$かい繰り返しているので、$NlogN$になります。

- f3

```cpp
int f3(int N) {
  int s = 0;
  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
      s++;
    }
  }
  return s;
}
```

これは$O(1)$です。$N$に関係なく、9 回の計算で終わります。

- f4

```cpp
int f4(int N) {
  int s = 0;
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
      s += i + j;
    }
  }
  return s;
}
```

これは$O(N^2)$です。$N$を 2 重に繰り返しているので、$N^2$になります。

- f5

```cpp
int f5(int N, int M) {
  int s = 0;
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < M; j++) {
      s += i + j;
    }
  }
  return s;
}
```

これは$O(NM)$です。$N$と$M$を 2 重に繰り返しているので、$NM$になります。
::::

# bit 演算

## bit

コンピュータは、0 と 1 の 2 進数で情報を表します。0 か 1 の 2 通りで表せる情報の最小単位を`bit`と呼びます。bit は、`binary digit`の略です。

## bit 演算子

bit 演算で主に使うものは以下の 6 つ

- AND: `&`
- OR: `|`
- XOR: `^`
- NOT: `~`
- 左シフト: `<<`
- 右シフト: `>>`

### AND

2 つの bit がともに 1 のときのみ 1 を返す演算子です。

| `x` | `y` | `x & y` |
| :-: | :-: | :-----: |
|  0  |  0  |    0    |
|  0  |  1  |    0    |
|  1  |  0  |    0    |
|  1  |  1  |    1    |

- $10$ & $12=1010_{(2)}$ & $1100_{(2)} = 1000_{(2)}$
- $10$ & $5=1010_{(2)}$ & $0101_{(2)} = 0000_{(2)}$

### OR

2 つの bit のどちらかが 1 のとき 1 を返す演算子です。

| `x` | `y` | `x \| y` |
| :-: | :-: | :------: |
|  0  |  0  |    0     |
|  0  |  1  |    1     |
|  1  |  0  |    1     |
|  1  |  1  |    1     |

- $10$ \| $12=1010_{(2)}$ \| $1100_{(2)} = 1110_{(2)}$
- $10$ \| $5=1010_{(2)}$ \| $0101_{(2)} = 1111_{(2)}$

### XOR

2 つの bit が異なるとき 1 を返す演算子です。

| `x` | `y` | `x ^ y` |
| :-: | :-: | :-----: |
|  0  |  0  |    0    |
|  0  |  1  |    1    |
|  1  |  0  |    1    |
|  1  |  1  |    0    |

- $10$ ^ $12=1010_{(2)}$ ^ $1100_{(2)} = 0110_{(2)}$
- $10$ ^ $5=1010_{(2)}$ ^ $0101_{(2)} = 1111_{(2)}$

### NOT

bit を反転させる演算子です。

| `x` | `~x` |
| :-: | :--: |
|  0  |  1   |
|  1  |  0   |

- ~$10$ = ~$1010_{(2)}$ = $0101_{(2)}$

### 左シフト

bit を左にシフトさせる演算子です。右側に 0 が追加されます。
`x<<n`と書いたとき、$2^n$ を掛けることと同じです。

- $10$ << $2$ = $1010_{(2)}$ << $2$ = $101000_{(2)}$ = $40$

### 右シフト

bit を右にシフトさせる演算子です。左側に 0 が追加されます。
`x>>n`と書いたとき、$2^n$ を割ることと同じです。

- $10$ >> $2$ = $1010_{(2)}$ >> $2$ = $10_{(2)}$ = $2$

### 複合代入演算子

|   演算   | 演算子 |
| :------: | :----: |
|   AND    |  `&=`  |
|    OR    | `\|=`  |
|   XOR    |  `^=`  |
| 左シフト | `<<=`  |
| 右シフト | `>>=`  |

### bit 演算の注意

符号あり整数型の場合(int,long long)、最上位 bit は符号を表すので、bit 演算を行うときは、符号なし整数型(unsigned int,unsigned long long)を使うようにしましょう。

# bit 全探索

AtCoder でよく出ます。bit 全探索とは、bit を使って全探索を行う方法です。bit 全探索は、$2^N$通りの組み合わせを全て試すことができます。シフト演算とAND演算が理解できていれば分かります。

## 例題

$1,2,4$の中から自由に数字を選んでいくつの数字を作ることができるか。一つも選ばないこともできる。

### 考え方

3 つのこの数字を選ぶ、選ばないの 2 パターンを bit で表す。$0$から$2^n-1$まで今回は$2^3-1$まで調べる。
|数字|4|2|1|作られる数字|
|:-:|:-:|:-:|:-:|:-:|
|$0(000_{(2)})$|x|x|x|0|
|$1(001_{(2)})$|x|x|o|1|
|$2(010_{(2)})$|x|o|x|2|
|$3(011_{(2)})$|x|o|o|3|
|$4(100_{(2)})$|o|x|x|4|
|$5(101_{(2)})$|o|x|o|5|
|$6(110_{(2)})$|o|o|x|6|
|$7(111_{(2)})$|o|o|o|7|

### コード

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    vector<int> a={1,2,4};
    int n=3;
    for(int bit=0;bit<(1<<n);bit++){ // 1<<nは2^n
        int sum=0;
        for(int i=0;i<n;i++){
            if(bit&(1<<i)){ // bitのi番目のbitが立っているかどうか
                sum+=a[i];
            }
        }
        cout<<sum<<endl;
    }
}
```

### 例題

<https://atcoder.jp/contests/abc289/tasks/abc289_c>

:::details ヒント

- 問題の言っていることは、選び出した集合の中に$1$から$N$までの数字が含まれていますかということ。
- 集合は set で扱います。
  :::

:::details 解答例

````cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n, m;
    cin >> n >> m;
    vector<set<int>> a(m);
    for (int i = 0; i < m; i++)
    {
        int size = 0;
        cin >> size;
        for (int j = 0; j < size; j++)
        {
            int x;
            cin >> x;
            a[i].insert(x);
        }
    }

    int ans = 0;
    for (int bit = 0; bit < (1 << m); bit++) // 0 ~ 2^m - 1くりかえす
    {
        set<int> s;
        for (int i = 0; i < m; i++)
        {
            if (bit & (1 << i))  // bitのi番目のフラグが立っているかどうか
            {
                for (auto x : a[i])
                {
                    s.insert(x);
                }
            }
        }
        if ((int)s.size() == n)
        {
            ans++;
        }
    }
    cout << ans << endl;
}
:::

# bitset

- int型は$32$bit, long long型は$64$bitまでしか扱えない。
- bitsetは、任意の長さのbit列を扱うことができる。
- bitsetは、ビット演算が高速に行える。

### 宣言

```cpp
bitset<長さ> 変数名;
bitset<4> bs; // 4bitのbit列
bitset<4> bs("1010"); // 4bitのbit列で初期化
````

### 代入

```cpp
bs=5; // 5=101
bs=bitset<4>("1010");
bs=0b1010; // 0bで2進数を表すことができる
```

### 演算

bitset は bit 演算の演算子はすべて使える。

### メソッド

| メソッド |           説明           |
| :------: | :----------------------: |
| .count() |      1 の数を数える      |
|  .set()  |  全ての bit を 1 にする  |
| .set(i,j)  | i 番目の bit を j にする |
|  .reset()  |  全ての bit を 0 にする  |
| .reset(i)  | i 番目の bit を 0 にする |
|  .flip()  |  全ての bit を反転する  |
| .flip(i)  | i 番目の bit を反転する  |
| .to_string() | bitset を文字列に変換する |

