---
title: "【第5回】 データベースを触ってみよう"
description: "今回はWebアプリを作る上で必要不可欠なデータベースについて学びます。SQLを使って、実際にsqlite3を操作してみましょう。"
date: "2023-05-22"
authors: ["sor4chi"]
tags: ["Web研究会", "sql", "database"]
---

## はじめに

今まで、第1,2回でHTMLとCSSとJavascript、第3,4回でGitとGithubを学びました。
これを使えば実際に動く**Webアプリ**を作ることができます。
しかし、実際に実用的なWebアプリを作るには、情報が書き換わったり、保存・登録ができるようにする必要がありますよね。

例えば**Twitter**を考えてみましょう。
Twitterは、ツイートを投稿したり、他の人のツイートを見たりすることができます。

この**投稿**という行動では、ツイートをTwitter社のサーバーに保存するという「**書き込み**」の行為が行われています。

一方で、**閲覧**という行動では、Twitter社のサーバーからツイートを取得して、自分の画面に表示するという「**読み込み**」の行為が行われています。

これらの行為を実現するためには、**データベース**という仕組みが必要になります。

この**データベース**は**2分探索**や**ハッシュテーブル**、**計算量最適化**などの競技プログラミングで学ぶアルゴリズム的知識が活かせるので、競プロ勢にはおすすめです（Web勢の勝手な思い込み）。

## データベースとは

データベースとは、データを保存するための仕組みです。
データベースを使うことで、データを保存したり、取得したり、更新したりすることができます。

いろいろなデータベースがあり、それぞれ異なる保存形式やパフォーマンス、機能を持っています。
これらを説明し始めるとキリがないので、今回は**sqlite3**というデータベースを使ってデータベースの基本的な操作を学びます。

このデータベースはみなさんが普段使うようなExcelと似たようなもので、データを表形式・単一のファイルで保存することができます。
単一のファイルで保存することができるので、データベースを扱うためのサーバーを用意する必要がなく、初心者には扱いやすいデータベースです。

## SQLite3をインストールしよう

まずは、SQLite3をインストールしましょう。
ターミナルを開き、以下のコマンドを実行してください。

```bash
# WSL2/Ubuntuの場合です、他の環境の場合は調べてください
sudo apt install sqlite3
```

## 関係データベース

データベースには、いろいろな種類があります。
今回は、sqlite3が対応している形式である**関係データベース**（リレーショナルデータベース）という種類のデータベースを使います。

関係データベースでは、データを表形式で保存します。
この表のことを**テーブル**と呼びます。
また、テーブルの中の一つ一つのデータのことを**レコード**と呼びます。

例えば、Twitterのツイートを保存するテーブルを作るとします。
このテーブルには、ツイートの内容や投稿者の情報などが保存されます。

このテーブルは、以下のような形式で保存されます。

| id | content | user_id | created_at |
| --- | --- | --- | --- |
| 1 | あけましておめでとう！ | 3 | 2023-01-01 00:00:00 |
| 2 | 今年もよろしくお願いします！ | 2 | 2023-01-01 00:00:01 |
| 3 | 今年こそは痩せるぞ！ | 1 | 2023-01-01 00:00:02 |

後で使うのでこのテーブルを**ツイートテーブル**と呼ぶことにします。
このように、テーブルは**列**（カラム）と**行**（レコード）で構成されています。

それぞれの列は、**カラム名**と**データ型**を持っています。

カラム名は、その列に保存されるデータの種類を表しています。この例では、`id`はツイートのID、`content`はツイートの内容、`user_id`はツイートを投稿したユーザーのID、`created_at`はツイートを投稿した日時を表しています。

また、データ型は、その列に保存されるデータの種類を表しています。この例では、`id`は整数、`content`は文字列、`user_id`は整数、`created_at`は日時を表しています。

### リレーション

関係データベースでは、複数のテーブルを作ることができます。
このテーブル同士の関係を**リレーション**と呼びます。

次に、ツイートを投稿したユーザーの情報を保存するテーブルを作るとします。

このテーブルは、以下のような形式で保存されます。

| id | name | email | created_at |
| --- | --- | --- | --- |
| 1 | 佐藤太郎 | <satotaro@example.com> | 2022-08-15 00:00:00 |
| 2 | 鈴木次郎 | <suzukijiro@example.com> | 2022-09-03 00:00:00 |
| 3 | 田中三郎 | <tanakasaburo@example.com> | 2022-10-11 00:00:00 |

このテーブルを**ユーザーテーブル**と呼ぶことにします。

さっきのツイートテーブルとユーザーテーブルを見比べると、`user_id`という列があります。
この列は、ツイートテーブルとユーザーテーブルの**リレーション**（関係）を表しています。

では問題です。

> ツイート`id=1`のツイートを投稿したユーザーは誰でしょうか？

:::details[答え]
ツイート`id=1`のツイートを投稿したユーザーは、ユーザー`id=3`のユーザーです。
ユーザー`id=3`のユーザーの名前は、田中三郎です。
:::

このように、リレーションを使うことで、複数のテーブルを組み合わせてデータを取得することができます。
こうやって一つ一つの**テーブル**とその**リレーション**を組み合わせてデータを保存することで、複雑なデータを保存することができます。

## SQL (基礎)

データベースを操作するためには、**SQL**という言語を使います。
SQLは、データベースに対して、データの取得や保存、更新などの操作を行うための言語です。

まずは、SQLの基本的な操作を学びましょう。

### 準備

最初に、データベースを操作するための準備をします。
ターミナルを開き、以下のコマンドを実行してください。

```bash
# データベースファイルを作成
touch database.db

# データベースファイルを開く
sqlite3 database.db
```

### テーブルの作成

まずは、テーブルを作成してみましょう。
さっきのツイートテーブルを作成してみます。

```sql
CREATE TABLE tweets (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  content TEXT NOT NULL,
  user_id INTEGER NOT NULL,
  created_at DATETIME NOT NULL
);
```

このコマンドを実行すると、`tweets`という名前のテーブルが作成されます。
確認してみましょう。

```sql
# テーブル一覧を表示
.tables

# テーブルの構造を表示
.schema tweets
```

`CREATE TABLE <テーブル名> (<カラム名> <データ型> <制約>, ...);`という形式でテーブルを作成することができます。

`<カラム名> <データ型> <制約>`の部分を**カラム定義**と呼びます。

`<カラム名>`は、その列の名前を表しています。

`<データ型>`は、その列に保存されるデータの種類を表しています。
`INTEGER`は整数、`TEXT`は文字列、`DATETIME`は日時を表しています。

`<制約>`には、以下のようなものがあります。

- `PRIMARY KEY`：主キーを設定します。主キーは、そのテーブルのレコードを一意に識別するためのものです。主キーは、`INTEGER`型の列に設定することが多いです。
- `AUTOINCREMENT`：主キーを自動で増やします。主キーを設定した列に設定することが多いです。
- `NOT NULL`：その列には、必ず値を入れる必要があります。
- `UNIQUE`：その列には、同じ値を入れることができません。
- `DEFAULT <デフォルト値>`：その列に値が入っていない場合、デフォルト値を入れます。

### レコードの取得

次に、レコードを取得してみましょう。
さっきのツイートテーブルから、ツイートを取得してみます。

```sql
SELECT * FROM tweets;
```

`SELECT * FROM <テーブル名>;`という形式でレコードを取得することができます。

`*`は、全ての列を表しています。
`SELECT <カラム名>, ... FROM <テーブル名>;`という形式で、特定の列を取得することもできます。
`SELECT content FROM tweets;`みたいな感じですね。

では実行してみましょう。

```sql
SELECT * FROM tweets;
```

今のところ、レコードがありませんね。なにも表示されません。

### レコードの挿入

次に、レコードを挿入してみましょう。
さっきのツイートテーブルに、ツイートを挿入してみます。

```sql
INSERT INTO tweets (content, user_id, created_at) VALUES ('あけましておめでとう！', 3, '2023-01-01 00:00:00');
INSERT INTO tweets (content, user_id, created_at) VALUES ('今年もよろしくお願いします！', 2, '2023-01-01 00:00:01');
INSERT INTO tweets (content, user_id, created_at) VALUES ('今年こそは痩せるぞ！', 1, '2023-01-01 00:00:02');
```

`INSERT INTO <テーブル名> (<カラム名>, ...) VALUES (<値>, ...);`という形式でレコードを挿入することができます。

これで、ツイートテーブルにレコードが挿入されました。
確認してみましょう。

```sql
SELECT * FROM tweets;
```

```txt
1|あけましておめでとう！|3|2023-01-01 00:00:00
2|今年もよろしくお願いします！|2|2023-01-01 00:00:01
3|今年こそは痩せるぞ！|1|2023-01-01 00:00:02
```

と表示されれば成功です。

### レコードの更新

次に、レコードを更新してみましょう。
さっきのツイートテーブルの、ツイート`id=1`の内容を更新してみます。

```sql
UPDATE tweets SET content = 'あけおめ！' WHERE id = 1;
```

`UPDATE <テーブル名> SET <カラム名> = <値>, ... WHERE <条件>;`という形式でレコードを更新することができます。

これで、ツイートテーブルのツイート`id=1`の内容が更新されました。

確認してみましょう。

```sql
SELECT * FROM tweets;
```

```txt
1|あけおめ！|3|2023-01-01 00:00:00
2|今年もよろしくお願いします！|2|2023-01-01 00:00:01
3|今年こそは痩せるぞ！|1|2023-01-01 00:00:02
```

と表示されれば成功です。

### レコードの削除

最後に、レコードを削除してみましょう。
さっきのツイートテーブルの、ツイート`id=1`を削除してみます。

```sql
DELETE FROM tweets WHERE id = 1;
```

`DELETE FROM <テーブル名> WHERE <条件>;`という形式でレコードを削除することができます。

これで、ツイートテーブルのツイート`id=1`が削除されました。

確認してみましょう。

```sql
SELECT * FROM tweets;
```

```txt
2|今年もよろしくお願いします！|2|2023-01-01 00:00:01
3|今年こそは痩せるぞ！|1|2023-01-01 00:00:02
```

と表示されれば成功です。

## SQL (応用)

次に**ユーザーテーブル**を作成してみましょう。

```sql
CREATE TABLE users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  created_at DATETIME NOT NULL
);
```

このテーブルに、ユーザーを挿入してみましょう。

```sql
INSERT INTO users (name, email, created_at) VALUES ('佐藤太郎', 'satotaro@example.com', '2022-08-15 00:00:00');
INSERT INTO users (name, email, created_at) VALUES ('鈴木次郎', 'suzukijiro@example.com', '2022-09-03 00:00:00');
INSERT INTO users (name, email, created_at) VALUES ('田中三郎', 'tanakasaburo@example.com', '2022-10-11 00:00:00');
```

これで、ユーザーテーブルにレコードが挿入されました。
確認してみましょう。

```sql
SELECT * FROM users;
```

```txt
1|佐藤太郎|satotaro@example.com|2022-08-15 00:00:00
2|鈴木次郎|suzukijiro@example.com|2022-09-03 00:00:00
3|田中三郎|tanakasaburo@example.com|2022-10-11 00:00:00
```

と表示されれば成功です。

### レコードの取得 (応用)

さっきの問題を思い出してみましょう。

> ツイート`id=1`のツイートを投稿したユーザーは誰でしょうか？

という問題です。

これをSQLで表してみましょう。まず2つのクエリに分解してみます。

ツイート`id=1`のツイートを取得する

```sql
SELECT * FROM tweets WHERE id = 1;
```

ユーザー`id=3`のユーザー名を取得する

```sql
SELECT name FROM users WHERE id = 3;
```

これらを組み合わせて、ツイート`id=1`のツイートを投稿したユーザーを取得するクエリを作成します。

```sql
SELECT name FROM users WHERE id = (SELECT user_id FROM tweets WHERE id = 1);
```

これで、ツイート`id=1`のツイートを投稿したユーザーを取得することができました。

ここで、`SELECT user_id FROM tweets WHERE id = 1`というクエリを**サブクエリ**と呼びます。
サブクエリは、クエリの中に入れ子になっているクエリのことを指します。

## アプリケーションとの連携

今までは、データベースを直接操作していました。
しかし、実際には直接データベースを操作することはほとんどありません。

例えば、ツイートを投稿しようとする場合

1. ツイートを投稿する
2. ツイートをデータベースに保存する
3. フォローしているユーザーを取得する
4. フォローしているユーザーから通知をONにしているユーザーを取得する
5. 通知をONにしているユーザーに通知を送る
6. ツイートを表示する

みたいな感じでSQLだけで解決できない複雑な処理を行うために、アプリケーションを作成してデータベースを操作することが多いです。
また、直接データベースがアクセスできる環境を作ると、SQLインジェクションなどのセキュリティ上の問題がより発生しやすくなるので、アプリケーションを作成してデータベースを操作することが多いです。

### 3層アーキテクチャ

アプリケーションを作成するときには、**3層アーキテクチャ**という考え方を使うことが多いです。

3層アーキテクチャでは、アプリケーションを3つの層に分けて考えます。

- プレゼンテーション層
- アプリケーション層
- データベース層

#### プレゼンテーション層

プレゼンテーション層は、ユーザーとのやり取りを行う層です。
例えば、ツイートを投稿する画面や、ツイートを表示する画面などがあります。

俗にいう**フロントエンド**です。サイトやスマホアプリなどが該当します。

#### アプリケーション層

アプリケーション層は、プレゼンテーション層とデータベース層の橋渡しを行う層です。書き込みや読み込み、定期的な処理などを行います。

例えば、ツイートを投稿する画面でツイートを投稿したときに、ツイートをデータベースに保存する処理を行います。

#### データベース層

言わずもがなですね。

Webアプリケーションを作ろう！と思ったら、まずは3層アーキテクチャを意識してみましょう。
これが一番ベーシックなアーキテクチャです。

**バックエンド**は、アプリケーション層とデータベース層を指すことが多いです。

### データベースとの連携

データベースとの連携は、アプリケーション層で行います。
**SQL**をネットワーク経由でデータベースに送信して、データベースを操作するみたいな感じです。
（sqlite3はファイルベースなので、ネットワーク経由ではなくファイル経由でデータベースを操作しますが）

新しいディレクトリを作成します。
ログを残しておくために、gitを初期化しておきましょう。

```bash
git init
```

次に、データベースを操作するためのライブラリをインストールします。

```bash
npm install sqlite3
```

次に、`index.js`を作成します。

```js:index.js
const sqlite3 = require('sqlite3').verbose();

const db = new sqlite3.Database('database.db');

db.close();
```

`db.close()`は、データベースとの接続を切断する関数です。これは、データベースとの接続を切断しないと、データベースファイルを削除したり、別のプログラムからデータベースにアクセスできなくなったりするので、必ずプログラムの最後に書いておきましょう。

次に、`database.db`は頻繁にデータが書き変わるので、これを`git`で管理してしまうと毎回のコミットでデータベースの変更がコミットされてしまいます。
そのため、`.gitignore`に`database.db`を追加しておきましょう。

```bash
# コマンド使ってますが、別に`.gitignore`って名前でファイルを作って`database.db`って書いてもOKです
echo database.db >> .gitignore
```

こうすることで、`git`で管理されなくなります。

**データベースと接続する**という機能ができたので、コミットしておきましょう。

```bash
git add .
git commit -m "データベースと接続する"
```

### ユーザーとツイートのテーブルを作成

まず、`queries.js`を作成します。

```js:queries.js
const Tweets = {
    createTable: `
        CREATE TABLE tweets IF NOT EXISTS (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            content TEXT NOT NULL,
            user_id INTEGER NOT NULL,
            created_at DATETIME NOT NULL
        );
    `,
};

const Users = {
    createTable: `
        CREATE TABLE users IF NOT EXISTS (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            email TEXT NOT NULL,
            created_at DATETIME NOT NULL
        );
    `,
};

module.exports = {
    Tweets,
    Users,
};
```

次に、`index.js`を以下のように編集します。

```js:index.js {6-9}
const sqlite3 = require('sqlite3').verbose();
const queries = require('./queries');

const db = new sqlite3.Database('database.db');

db.serialize(() => {
    db.run(queries.Tweets.createTable);
    db.run(queries.Users.createTable);
});

db.close();
```

`IF NOT EXISTS`というのは、テーブルが存在しない場合にのみテーブルを作成するという意味です。
これをつけておくことで最初にこのファイルを実行したときにテーブルが作成され、2回目以降はテーブルが存在するのでテーブルが作成されないようにします。

`db.serialize`の中に書いた処理は、順番に実行されます。
`db.run`は、SQLを実行する関数です。

では実行してみましょう。

```bash
node index.js
```

`database.db`が作成されていれば成功です。
`database.db`を開いて、テーブルが作成されていることを確認してみましょう。

```bash
sqlite3 database.db
```

```sql
.tables
```

```txt
tweets  users
```

と表示されれば成功です。

それではテーブルを作成する機能ができたので、コミットしておきましょう。

```bash
git add .
git commit -m "ユーザーとツイートのテーブルを作成"
```

### ユーザーを作成できるようにする

次に、ユーザーを作成できるようにしてみましょう。
`queries.js`を以下のように編集します。

```js:queries.js {10}
const Users = {
    createTable: `
        CREATE TABLE users IF NOT EXISTS (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            email TEXT NOT NULL,
            created_at DATETIME NOT NULL
        );
    `,
    create: `INSERT INTO users (name, email, created_at) VALUES (?, ?, ?);`,
};
```

そして、`index.js`を以下のように編集します。

```js:index.js {10}
const sqlite3 = require('sqlite3').verbose();
const queries = require('./queries');

const db = new sqlite3.Database('database.db');

db.serialize(() => {
    db.run(queries.Tweets.createTable);
    db.run(queries.Users.createTable);

    db.run(queries.Users.create, 'りんご太郎', 'apple@example.com', '2022-08-15 00:00:00');
});

db.close();
```

`?`は、後から値を埋め込むための**プレースホルダ**と呼ばれるものです。

:::details[?を含むクエリに関する補足]
`User.create`のクエリを

```js
create(name, email, created_at): `INSERT INTO users (name, email, created_at) VALUES ('${name}', '${email}', '${created_at}');`,
```

にしないの？と思うかもしれません。

しかし、このようにすると、SQLインジェクションというセキュリティ上の問題が発生します。
たとえば、`name`に`'); DROP TABLE users; --`という文字列を入れると、出力されるクエリは以下のようになります。

```sql
INSERT INTO users (name, email, created_at) VALUES (''); DROP TABLE users; --', 'hacker@example.com', '2023-05-21 00:00:00');
```

これにより、本来意図していないテーブルの削除が行われてしまいます。
そのため、`?`を使って、SQLインジェクションを防ぐようにしましょう。
これを使えば攻撃性のある命令に使われる特殊文字`'; --`などを命令ではなくそのまま文字列として埋め込むことができます。
:::

では実行してみましょう。

```bash
node index.js
```

`database.db`を開いて、ユーザーが作成されていることを確認してみましょう。

```bash
sqlite3 database.db
```

```sql
SELECT * FROM users;
```

```txt
1|りんご太郎|apple@example.com|2022-08-15 00:00:00
```

と表示されれば成功です。

それではユーザーを作成できるようにする機能ができたので、コミットしておきましょう。

```bash
git add .
git commit -m "ユーザーを作成できるようにする"
```
